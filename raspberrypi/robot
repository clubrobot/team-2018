#!/usr/bin/env python3

import os, sys
import time
from argparse  import ArgumentParser
from threading import Thread

sys.path.append("{}/common/".format(sys.path[0]))
sys.path.append("{}/robots/".format(sys.path[0]))

from serialtalks import SerialTalks
from buttons import ButtonCard
from devmode import ButtonGesture
from display import SevenSegments
from components  import Server, Manager
#from bornibus    import Bornibus
#from murray      import Murray

DEV_MODE = True


arduino_list=['sensors', 'wheeledbase', 'power', 'display', 'modulescollector', 'mineralscollector']

class Starter(Thread):
	def __init__(self,ggb,wheeledbase,greenbutton,redbutton,bluebutton,yellowbutton,switch):
		self.state = "waiting_team"

        ################################################################
        #waiting_team : en attente du choix d'équipe                   #
        #waiting_launch : en attente de la validation de lancement     #
        #launch_asking : Demande le lancement (verif du switch)        #
        #launching  : lancement (attente du switch)                    # 
        #launched : fin du lancement                                   #
        ################################################################

		self.team = "none" # nom de l'équipe choisie
		self.Ggb = ggb
		self.WheeledBase = wheeledbase
		self.RedButton = redbutton
		self.BlueButton = bluebutton
		self.YellowButton = yellowbutton
		self.GreenButton = greenbutton
		self.Switch = switch
		self.RedButton.Off()
		self.BlueButton.Off()
		self.YellowButton.Off()
		self.GreenButton.Off()
		self.RedButton.SetFunction(self.setState,"Red")
		self.BlueButton.SetFunction(self.setState,"Blue")
		self.YellowButton.SetFunction(self.setState,"Yellow")
		self.GreenButton.SetFunction(self.setState,"Green")
		self.Switch.SetFunction(self.setState,"Switch")
		Thread.__init__(self)
		self.daemon = True
		self.start()


	def setState(self,name):
		if name in ("Blue","Yellow") and self.state=="waiting_team":
			self.state="waiting_pos"
			self.team = name

		if name=="Green" and self.state== "waiting_launch":
			self.state = "launch_asking"

		if name=="Switch" and self.state =="launching":
			self.state = "launched"


	def run(self):
		self.BlueButton.On()
		self.YellowButton.On()
		self.RedButton.On()
		while(self.state!="launched" and self.state!="Exiting"):

			time.sleep(0.1)
			if self.state=="Exiting":
				self.BlueButton.Off()
				self.YellowButton.Off()
				self.RedButton.Off()
				self.GreenButton.Off()

			if self.state=="waiting_pos":
				if self.team=="Blue":
					self.BlueButton.On()
					self.YellowButton.Off()
					self.RedButton.On()
					self.GreenButton.On()
					x, y = self.Ggb.get('start_{1, position}')
					theta = self.Ggb.get('start_{1, orientation}')
					self.WheeledBase.set_position(x, y, theta)
				else:
					self.BlueButton.Off()
					self.YellowButton.On()
					self.RedButton.On()
					self.GreenButton.On()
					x, y = self.Ggb.get('start_{0, position}')
					theta = self.Ggb.get('start_{0, orientation}')
					self.WheeledBase.set_position(x, y, theta)
				self.state = "waiting_launch"

			if self.state=="launch_asking": 

				if self.Switch.state==False:
                    
					self.state="waiting_launch"
				else:
					self.GreenButton.Off()
					self.state="launching"         

		self.RedButton.Off()
		self.GreenButton.Off()


def buttons():
	if not DEV_MODE : return
	m = Manager()
	m.connect()
	try:
		button_card = ButtonCard(m)
		screen      = SevenSegments(m)
	except:
		return 
	button_gesture = ButtonGesture(button_card,screen,m)
	while not button_gesture.exiting : time.sleep(0.2)
	button_card.disconnect()
	screen.disconnect()


def getuuid(args):
	talks = SerialTalks(args.port)
	try:
		talks.connect(args.timeout)
		uuid = talks.getuuid(args.timeout)
		if isinstance(uuid, str):
			print(uuid)
		else:
			raise ValueError('\'{}\' object is not a valid UUID'.format(type(uuid)))
	except KeyboardInterrupt:
		pass
	finally:
		talks.disconnect()


def showip(args):

	try: 
		ssg = SerialTalks(os.path.join('/dev/arduino', 'display'))
		ssg.connect()
		import subprocess
		from serialtalks import STRING
		ip = ''
		while not ip:
			proc = subprocess.run(['hostname', '-I'], stdout=subprocess.PIPE)
			ip = proc.stdout.strip().decode('utf8')
		ssg.send(0x0E, STRING(ip))

		ssg.disconnect()
	except:
		pass
		


def getlogs(args):
	talks = SerialTalks(args.port)
	try:
		talks.connect(args.timeout)
		while True:
			sys.stdout.write(talks.getout())
			sys.stderr.write(talks.geterr())
	except KeyboardInterrupt:
		pass
	finally:
		talks.disconnect()


def server(args):
	srv = Server(password=args.password,size=args.size)
	if DEV_MODE : Thread(target=buttons,daemon=True).start()
	while True:
		try:
			while not srv.full():
				srv.connect(None)
			srv.sleep_until_one_disconnected()

		except KeyboardInterrupt:
			srv.disconnect()
			break
		except Exception as e:
			sys.stderr.write('{}: {}\n'.format(type(e).__name__, e))
			continue


def start(args):
	global robot
	if args.name == 'bornibus':
		robot = Bornibus(args.ip, timelimit=args.timelimit)
		robot.log('hi there, this is Bornibus!')
	elif args.name == 'murray':
		robot = Murray(args.ip, timelimit=args.timelimit)
		robot.log('hello everyone, I am Murray!')
	
	# Connect to the components server
	robot.log('connect to server')
	robot.connect(timeout=args.timeout)
	robot.log('connected')
	
	# Load the roadmap
	if args.roadmap is not None:
		robot.log('load roadmap: {}'.format(args.roadmap))
		robot.load_roadmap(args.roadmap)
		robot.log('loaded')

	# Bluetooth connection
	robot.connect_to_brother(macaddress=args.bluetooth)

	# Initialization procedure
	robot.log("let's get ready to rumble")
	starter = Starter(robot.geogebra, robot.wheeledbase, robot.greenbutton, robot.redbutton, robot.bluebutton, robot.yellowbutton, robot.pullswitch)
	starter.join()
	if (starter.state=="Exiting"):
		robot.log('thank you!')
		sys.exit(0)
	
	# Start match
	if starter.team == "Yellow":
		robot.side = 0
	elif starter.team == "Blue":
		robot.side = 1
	robot.start()

# Update arduino programs
def update(args):
	import subprocess

	# List all the arduino which should be updated
	if args.arduino != "all":
		arduinos_to_verify=[args.arduino]
	else:
		arduinos_to_verify=arduino_list

	arduinos_to_update = []
	
	# Verify if the code of the arduino changed since last update (can be forced)
	if not args.force:
		for arduino in arduinos_to_verify:
			arduino_path = os.path.dirname(os.path.realpath(__file__)) + '/../arduino/' + arduino
			gitdiff = subprocess.run(['/usr/bin/git', 'diff', '--quiet', '--exit-code', arduino_path])
			if gitdiff.returncode == 0:
				print(arduino + " up to date")
			else:
				arduinos_to_update += [arduino]

	else:
		arduinos_to_update = arduinos_to_verify

	# Git pull
	subprocess.run(['/usr/bin/git', 'pull', '-f'], stdout=subprocess.PIPE)

	# Execute make upload for the selected arduinos 
	for arduino in arduinos_to_update:
		arduino_path = os.path.dirname(os.path.realpath(__file__)) + '/../arduino/' + arduino
		print("updating " + arduino)
		subprocess.run(['/usr/bin/make', 'upload_safe', '-C', arduino_path])

parser = ArgumentParser()
subparsers = parser.add_subparsers()

getuuid_parser = subparsers.add_parser('getuuid')
getuuid_parser.add_argument('port', type=str)
getuuid_parser.add_argument('-t', '--timeout', type=float, default=5)
getuuid_parser.set_defaults(func=getuuid)

getlogs_parser = subparsers.add_parser('getlogs')
getlogs_parser.add_argument('port', type=str)
getlogs_parser.add_argument('-t', '--timeout', type=float, default=5)
getlogs_parser.set_defaults(func=getlogs)

server_parser = subparsers.add_parser('server')
server_parser.add_argument('-p', '--password', type=str, default=None)
server_parser.add_argument('-s', '--size'    , type=int, default=4   )
server_parser.set_defaults(func=server)

showip_parser = subparsers.add_parser('showip')
showip_parser.set_defaults(func=showip)


start_parser = subparsers.add_parser('start')
start_parser.add_argument('name', type=str, choices=('bornibus', 'murray'))
start_parser.add_argument('-i', '--ip', type=str, default='localhost')
start_parser.add_argument('-r', '--roadmap', type=str, default=None)
start_parser.add_argument('-t', '--timeout', type=int, default=5)
start_parser.add_argument('-T', '--timelimit', type=int, default=None)
start_parser.add_argument('-b', '--bluetooth', type=str, default=None)
start_parser.set_defaults(func=start)

update_parser = subparsers.add_parser('update')
update_parser.add_argument('arduino', type=str, default='all', choices=arduino_list + ['all'])
update_parser.add_argument('-f', '--force', action="store_true", required=False, default=False)
update_parser.set_defaults(func=update)



args = parser.parse_args()
args.func(args)

